<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>can i ride dirt?</title>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    background: #f0f1f3;
    color: #333;
    min-height: 100vh;
    padding: 1rem;
  }
  .container {
    max-width: 600px;
    margin: 2rem auto;
  }
  h1 {
    text-align: center;
    margin-bottom: 0.25rem;
    font-size: 1.4rem;
    color: #666;
    font-weight: 400;
    letter-spacing: 0.02em;
  }
  .subtitle {
    text-align: center;
    color: #aaa;
    margin-bottom: 1.5rem;
    font-size: 0.8rem;
  }
  * { text-transform: lowercase; }
  .search-box {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 1rem;
  }
  .search-box input {
    flex: 1;
    padding: 0.75rem 1rem;
    border: 2px solid #ccc;
    border-radius: 8px;
    font-size: 1rem;
    outline: none;
    transition: border-color 0.2s;
    height: 48px;
  }
  .search-box input::placeholder {
    font-size: 0.8rem;
  }
  .search-box input:focus { border-color: #888; }
  .search-box button {
    padding: 0.75rem 1.25rem;
    background: #555;
    color: #fff;
    border: none;
    border-radius: 8px;
    font-size: 1rem;
    cursor: pointer;
    white-space: nowrap;
    height: 48px;
  }
  .search-box button:hover { background: #333; }
  .search-box button:disabled { background: #aaa; cursor: not-allowed; }
  .locations {
    background: #fff;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    margin-bottom: 1rem;
    overflow: hidden;
  }
  .locations .loc-item {
    padding: 0.75rem 1rem;
    cursor: pointer;
    border-bottom: 1px solid #eee;
    transition: background 0.15s;
  }
  .locations .loc-item:last-child { border-bottom: none; }
  .locations .loc-item:hover { background: #f0f1f3; }
  .loc-name { font-weight: 600; }
  .loc-detail { font-size: 0.85rem; color: #777; }
  .result-card {
    background: #fff;
    border-radius: 12px;
    box-shadow: 0 2px 12px rgba(0,0,0,0.1);
    padding: 1.5rem;
    margin-top: 1rem;
  }
  .verdict {
    text-align: center;
    padding: 1rem;
    border-radius: 8px;
    margin-bottom: 1.25rem;
    font-size: 1.3rem;
    font-weight: 700;
  }
  .verdict.ok { background: #e6f9e6; color: #1a7a1a; }
  .verdict.wait { background: #fce8e8; color: #b91c1c; }
  .verdict.no-rain { background: #e6f9e6; color: #1a7a1a; }
  .stats { display: grid; gap: 0.75rem; }
  .stat-row {
    display: flex;
    justify-content: space-between;
    padding: 0.5rem 0;
    border-bottom: 1px solid #f0f0f0;
  }
  .stat-row:last-child { border-bottom: none; }
  .stat-label { color: #666; }
  .stat-value { font-weight: 600; }
  .day-breakdown {
    margin-top: 1rem;
    padding-top: 0.75rem;
    border-top: 2px solid #f0f0f0;
  }
  .day-breakdown h3 { font-size: 0.95rem; color: #666; margin-bottom: 0.5rem; }
  .day-row {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-bottom: 0.4rem;
    font-size: 0.85rem;
  }
  .day-label { width: 80px; color: #666; flex-shrink: 0; }
  .day-grid {
    display: flex;
    flex: 1;
    gap: 1px;
  }
  .hour-cell {
    flex: 1;
    height: 18px;
    border-radius: 2px;
    background: #d8dadd;
  }
  .hour-cell.rain { background: #6b9bd2; }
  .hour-cell.future { background: #eeeff1; }
  .day-amount { width: 60px; text-align: right; color: #555; flex-shrink: 0; }
  .loading {
    text-align: center;
    padding: 2rem;
    color: #888;
  }
  .error {
    text-align: center;
    padding: 1rem;
    color: #b91c1c;
    background: #fce8e8;
    border-radius: 8px;
    margin-top: 1rem;
  }
  .location-label {
    text-align: center;
    color: #888;
    font-size: 0.9rem;
    margin-bottom: 0.5rem;
  }
</style>
</head>
<body>
<div class="container">
  <h1><a href="#" onclick="resetPage(); return false;" style="color:inherit;text-decoration:none">can i ride dirt?</a></h1>
  <p class="subtitle">wait 24 hours per inch of rain before riding</p>

  <div class="search-box">
    <input type="text" id="location-input" placeholder="enter a location" />
    <button id="search-btn" onclick="searchLocation()">Search</button>
  </div>

  <div id="locations"></div>
  <div id="result"></div>
</div>

<script>
const input = document.getElementById('location-input');
const locDiv = document.getElementById('locations');
const resultDiv = document.getElementById('result');
const searchBtn = document.getElementById('search-btn');

function resetPage() {
  input.value = '';
  locDiv.innerHTML = '';
  resultDiv.innerHTML = '';
}

input.addEventListener('keydown', e => {
  if (e.key === 'Enter') searchLocation();
});

async function searchLocation() {
  const query = input.value.trim();
  if (!query) return;

  locDiv.innerHTML = '';
  resultDiv.innerHTML = '<div class="loading">Searching...</div>';
  searchBtn.disabled = true;

  try {
    // Check if input looks like coordinates (e.g. "37.16, -122.05")
    const coordMatch = query.match(/^(-?\d+\.?\d*)\s*[,\s]\s*(-?\d+\.?\d*)$/);
    if (coordMatch) {
      const lat = parseFloat(coordMatch[1]);
      const lon = parseFloat(coordMatch[2]);
      if (lat >= -90 && lat <= 90 && lon >= -180 && lon <= 180) {
        resultDiv.innerHTML = '';
        selectLocation({ name: `${lat.toFixed(4)}, ${lon.toFixed(4)}`, latitude: lat, longitude: lon });
        return;
      }
    }

    // Search both APIs in parallel and merge results
    // Open-Meteo is best for cities/towns; Nominatim knows landmarks, peaks, trails, etc.
    const [meteoResult, nominatimResult] = await Promise.allSettled([
      fetch(`https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(query)}&count=5`).then(r => r.json()),
      searchNominatim(query),
    ]);
    const meteoResp = meteoResult.status === 'fulfilled' ? meteoResult.value : {};
    const nominatimResults = nominatimResult.status === 'fulfilled' ? nominatimResult.value : [];
    let results = dedupeLocations([...normalizeOpenMeteo(meteoResp), ...nominatimResults]);

    if (results.length === 0) {
      resultDiv.innerHTML = '<div class="error">No locations found. Try a different search, or enter coordinates (e.g. 37.16, -122.05).</div>';
      return;
    }

    if (results.length === 1) {
      resultDiv.innerHTML = '';
      selectLocation(results[0]);
      return;
    }

    resultDiv.innerHTML = '';
    showLocationPicker(results);
  } catch (err) {
    resultDiv.innerHTML = `<div class="error">Search failed: ${esc(err.message)}</div>`;
  } finally {
    searchBtn.disabled = false;
  }
}

function normalizeOpenMeteo(data) {
  if (!data.results || data.results.length === 0) return [];
  return data.results.map(r => ({
    name: r.name,
    detail: [r.admin1, r.country].filter(Boolean).join(', '),
    latitude: r.latitude,
    longitude: r.longitude,
    admin1: r.admin1,
    country: r.country,
  }));
}

async function searchNominatim(query) {
  const resp = await fetch(`https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(query)}&format=json&limit=5&addressdetails=1`, {
    headers: { 'Accept': 'application/json' }
  });
  const data = await resp.json();
  return data.map(r => ({
    name: r.display_name.split(',')[0].trim(),
    detail: r.display_name.split(',').slice(1, 3).map(s => s.trim()).join(', '),
    latitude: parseFloat(r.lat),
    longitude: parseFloat(r.lon),
    admin1: r.address?.state,
    country: r.address?.country,
  }));
}

function dedupeLocations(locations) {
  const kept = [];
  for (const loc of locations) {
    const isDupe = kept.some(k =>
      Math.abs(k.latitude - loc.latitude) < 0.1 &&
      Math.abs(k.longitude - loc.longitude) < 0.1
    );
    if (!isDupe) kept.push(loc);
  }
  return kept.slice(0, 8);
}

function showLocationPicker(results) {
  locDiv.innerHTML = '<div class="locations">' +
    results.map((r, i) =>
      `<div class="loc-item" onclick="pickLocation(${i})">
        <div class="loc-name">${esc(r.name)}</div>
        <div class="loc-detail">${esc(r.detail)} (${r.latitude.toFixed(2)}, ${r.longitude.toFixed(2)})</div>
      </div>`
    ).join('') + '</div>';

  window._locResults = results;
}

function pickLocation(i) {
  selectLocation(window._locResults[i]);
}

async function selectLocation(loc) {
  locDiv.innerHTML = '';
  resultDiv.innerHTML = '<div class="loading">Fetching precipitation data...</div>';

  try {
    const url = `https://api.open-meteo.com/v1/forecast?latitude=${loc.latitude}&longitude=${loc.longitude}&hourly=precipitation&past_days=3&forecast_days=1&timezone=auto`;
    const resp = await fetch(url);
    const data = await resp.json();

    if (!data.hourly || !data.hourly.time || !data.hourly.precipitation) {
      resultDiv.innerHTML = '<div class="error">No precipitation data available for this location.</div>';
      return;
    }

    const times = data.hourly.time;
    const precip = data.hourly.precipitation;

    // Compute current time in the location's timezone for accurate comparisons
    const utcOffsetMs = (data.utc_offset_seconds || 0) * 1000;
    const localOffsetMs = new Date().getTimezoneOffset() * 60000;
    const locationNow = new Date(Date.now() + utcOffsetMs + localOffsetMs);
    const cutoff = new Date(locationNow.getTime() - 72 * 3600 * 1000);

    let totalMm = 0;
    let lastRainTime = null;
    let dryDebt = 0;
    let dryHoursPaidOff = 0;
    const dailyMm = {};
    const dailyHours = {}; // { dayKey: [{ hour, mm, future }] }

    for (let i = 0; i < times.length; i++) {
      const t = new Date(times[i]);
      if (t < cutoff) continue;

      const isFuture = t > locationNow;
      const mm = isFuture ? 0 : (precip[i] || 0);
      if (!isFuture) totalMm += mm;

      if (!isFuture && mm > 0) {
        lastRainTime = t;
        dryDebt += (mm / 25.4) * 24;
      } else if (!isFuture && dryDebt > 0) {
        const paid = Math.min(1, dryDebt);
        dryDebt -= paid;
        dryHoursPaidOff += paid;
      }

      const dayKey = t.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });
      dailyMm[dayKey] = (dailyMm[dayKey] || 0) + mm;
      if (!dailyHours[dayKey]) dailyHours[dayKey] = [];
      dailyHours[dayKey].push({ hour: t.getHours(), mm, future: isFuture });
    }

    const totalInches = totalMm / 25.4;
    let hoursSinceRain = lastRainTime ? (locationNow - lastRainTime) / 3600000 : null;
    let verdictHtml = '';

    if (lastRainTime === null) {
      verdictHtml = '<div class="verdict no-rain">No rain in the last 72 hours — ride on!</div>';
    } else if (dryDebt < 0.5) {
      verdictHtml = '<div class="verdict ok">OK to ride!</div>';
    } else {
      verdictHtml = `<div class="verdict wait">Wait ~${Math.ceil(dryDebt)} more hour${Math.ceil(dryDebt) === 1 ? '' : 's'}</div>`;
    }

    const dayRows = Object.entries(dailyHours).map(([day, hours]) => {
      const totalDayMm = dailyMm[day] || 0;
      const inches = totalDayMm / 25.4;
      const hourMap = {};
      hours.forEach(h => { hourMap[h.hour] = h; });
      let cells = '';
      for (let hr = 0; hr < 24; hr++) {
        const h = hourMap[hr];
        if (!h) {
          cells += `<div class="hour-cell future" title="${hr}:00"></div>`;
        } else {
          const cls = h.future ? 'future' : (h.mm > 0 ? 'rain' : '');
          const tip = h.future ? `${hr}:00` : (h.mm > 0 ? `${hr}:00 — ${(h.mm / 25.4).toFixed(3)} in` : `${hr}:00`);
          cells += `<div class="hour-cell ${cls}" title="${tip}"></div>`;
        }
      }
      return `<div class="day-row">
        <span class="day-label">${day}</span>
        <div class="day-grid">${cells}</div>
        <span class="day-amount">${inches < 0.005 ? '0.00' : inches.toFixed(2)}"</span>
      </div>`;
    }).join('');

    const locationLabel = loc.detail ? `${loc.name}, ${loc.detail}` : (loc.name || `${loc.latitude}, ${loc.longitude}`);

    resultDiv.innerHTML = `
      <div class="result-card">
        <div class="location-label">${esc(locationLabel)}</div>
        ${verdictHtml}
        <div class="stats">
          <div class="stat-row">
            <span class="stat-label">Total rainfall (72 hrs)</span>
            <span class="stat-value">${totalInches.toFixed(2)} in (${totalMm.toFixed(1)} mm)</span>
          </div>
          <div class="stat-row">
            <span class="stat-label">Drying elapsed</span>
            <span class="stat-value">${dryHoursPaidOff < 0.5 ? 'None' : '~' + Math.floor(dryHoursPaidOff) + ' hr'}</span>
          </div>
          <div class="stat-row">
            <span class="stat-label">Dry time needed</span>
            <span class="stat-value">${dryDebt < 0.5 ? 'None' : formatHrsMins(dryDebt)}</span>
          </div>
          <div class="stat-row">
            <span class="stat-label">Last rain</span>
            <span class="stat-value">${lastRainTime ? formatAgo(hoursSinceRain) : 'None in 72 hrs'}</span>
          </div>
        </div>
        <div class="day-breakdown">
          <h3>Rainfall by Day</h3>
          ${dayRows || '<div style="color:#888;font-size:0.85rem">No precipitation recorded</div>'}
        </div>
      </div>`;
  } catch (err) {
    resultDiv.innerHTML = `<div class="error">Failed to fetch data: ${esc(err.message)}</div>`;
  }
}

function formatHrsMins(hours) {
  let h = Math.floor(hours);
  let m = Math.round((hours - h) * 60);
  if (m === 60) { h++; m = 0; }
  if (h === 0) return `${m} min`;
  if (m === 0) return `${h} hr`;
  return `${h} hr + ${m} min`;
}

function formatAgo(hours) {
  if (hours < 1) return `${Math.round(hours * 60)} min ago`;
  if (hours < 24) return `${Math.floor(hours)} hr${Math.floor(hours) === 1 ? '' : 's'} ago`;
  const days = Math.floor(hours / 24);
  const rem = Math.floor(hours % 24);
  return `${days}d ${rem}h ago`;
}

function esc(s) {
  const d = document.createElement('div');
  d.textContent = s || '';
  return d.innerHTML;
}
</script>
</body>
</html>